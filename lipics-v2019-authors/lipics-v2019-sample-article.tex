\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2019}

%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
\usepackage{tabto}
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Decidability results of Communicating Finite
State Machines over acyclic topology } %TODO Please add

\titlerunning{} %TODO optional, please use if title is longer than one line

\author{G. Namratha Reddy}{Chennai Mathematical Institute, India \and  \url{http://www.cmi.ac.in/~namratha} }{}{}{}

\authorrunning{G. Namratha Reddy} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

% \Copyright{John Q. Public and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

% \ccsdesc[100]{\textcolor{red}{}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\ccsdesc[500]{Theory of computation~Distributed computing models}


\keywords{Distributed Systems, Reachability, Finite state machines with FIFO queues, Network of concurrent processes} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional nam-maybe-later

%\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \EventEditors{John Q. Open and Joan R. Access}
% \EventNoEds{2}
% \EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
% \EventShortTitle{CVIT 2016}
% \EventAcronym{CVIT}
% \EventYear{2016}
% \EventDate{December 24--27, 2016}
% \EventLocation{Little Whinging, United Kingdom}
% \EventLogo{}
% \SeriesVolume{42}
% \ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
    Models of concurrent finite state processes that communicate over queues allow different reachability results based on the underlying topology. The reachability is known to be undecidable for a general topology, but when we restrict to acyclic topologies it becomes decidable. The paper provides a proof of how it can be decided by reducing the problem to checking emptiness of a certain regular language. 
\end{abstract}

\section{Introduction}
\label{sec:typesetting-summary}

Distributed systems are becoming more and more popular. The ability to achieve with multiple cores/ computers for efficiency, reliability is highly enticing. Applications like block chain, database replication, ... 

These concurrent nature of these applications/programs makes their verification challenging. Techniques to solve this problem are in high demand. 

Formal methods uses mathematical formalism makes it easier to show that certain algorithms are not possible, maybe by showing that they are undecidable/decidable (atleast theoretically) which provides a motivation to develop efficient algorithms that can be used for practical purposes. 

Communicating finite state processes (cite paper) over queues has been a standard model for modelling concurrent non-recursive programs. 

One correctness idea for a concurrent program is to define via a safety property. Which states that a bad state should never be reached in my program. Which translates to asking in the model when we start with the initial configuration is it possible to reach this bad state. 
The answer to this question depends on the model we have considered. 
It turns out that for the communication finite state processes with queues it is undecidable to know if a state is reachable and this is shown because it is turing powerful (cite paper). But when restricted to certain class of topologies it allows for decidablity.


%Explain what exactly do these models model in the real world

%Why is this model helpful?

%Why is reachability important? 




\section{System topology}

\subsection{Model}


\paragraph*{Topology}
We work with a topology which we describe using the tuple 
\begin{center}
$\mathcal{T}= (\mathcal{P}, \mathcal{C}, r, w)$,
\end{center}
where \\
\hspace*{1cm} $\mathcal{P}$ is the set of processes; \\
\hspace*{1cm} $\mathcal{C}$ is the set of channels; \\
\hspace*{1cm} $r:\mathcal{C}  \rightarrow \mathcal{P}$ is the reader function that assigns to each channel a process that can read from it;\\
\hspace*{1cm} $w:\mathcal{C} \rightarrow \mathcal{P}$ is the writer function that assigns to each channel a process that can write to it.


\paragraph*{Channel}

Each channel $c \in \mathcal{C}$ has a message alphabet $\Gamma_c$.\\
Operations on the channel: 
\begin{itemize}
\item $c!m$ is a send operation. It appends the message $m$ to the end of channel $c$
\item $c?m$ is a read operation. It receives the message $m$ from the head of channel $c$ (enabled only if $m$ is at the head of channel $c$)

\end{itemize}


\paragraph*{Process}

Each process $p\in \mathcal{P}$ is modelled as a finite state transtion system 
\begin{center}
   $TS_p = (Q_p, \delta_p, s_p)$,
\end{center}
where \\
\hspace*{1cm} $Q_p$ is a finite set of states;\\
\hspace*{1cm} $\delta_p \subseteq Q_p \times O_p \times Q_p$ is a finite set of transitions, where, \\
\hspace*{2cm} $O_p = \{ c?m \hspace{1mm}| \hspace{1mm} r(c) = p,  m \in \Gamma_c\} \cup \{ c!m \hspace{1mm}| \hspace{1mm} w(c) = p, m \in \Gamma_c\}$; \\
\hspace*{1cm} $s_p$ is the initial state.



\subsection{Configuration Graph}

A configuration $(\alpha, \beta)$ of the system is a pair describing the states of all processes (control state) and the contents of all channels(channel state). \\
\hspace*{5cm} ${\displaystyle \alpha \in \prod_{i \in \mathcal{P}} Q_i}$, ${\displaystyle \beta \in \prod_{c \in \mathcal{C}} \Gamma_c^*}$\\
For any $p \in \mathcal{P}$, We write $\alpha(p)$ gives the state of process $p$, and for any $c \in \mathcal{C}$, $\beta(c)$ gives the content of channel $c$. $\alpha[p \leftarrow q]$ to be the control state  $\alpha'$ such that $\alpha'(p) = q$, and $\alpha'(p') = \alpha(p')$ if $p' \neq p$. Similarly, we define $\beta[c \leftarrow w]= \beta'$ such that $\beta'(c) = w$, and $\beta'(c') = \beta(c')$ if $c' \neq c$
\\
\\
Vertices in the configuration graph ($G = (V, E)$) are configurations, and the edges are labelled with channel operations. The edges need to satisfy the following conditions. \\
Let $(\alpha, \beta), (\alpha', \beta') \in V, c \in \mathcal{C}$, then 

% \begin{itemize}

A global configuration of the system would consist of the states of each process and the channel contents of each channel. So if we have n processes and m channels, a configuration would be the tuple $(q_0, q_1, ..., q_n, \gamma_1, \gamma_2, ..., \gamma_m)$


% decsribe how the edges of the global transition graph work

that is when a transition from one tuple to the next happens what all should align in the universe.

A run is a path in this graph 


\section{The Reachability Problem}

The reachability problem is to ask whether we can reach a target configuration where one or more processes are in a target state.

We know that the problem is undecidable in general (cite), because if there is a loop in the topology then we can simulate a queue machine and state reachability is undecidable for queue machines. 

So we ask the question of whether it is decidable for acyclic topologies.

What we mean by acyclic topologies is consider the network topology and ignore the direction of the edges, so we get an undirected graph and this graph should have no cycles.

We solve this with the help of two reductions

\paragraph*{Reduction 1}

given such an acyclic topology the reachability problem can be reduced to one in which the target state is reached only if the queue is empty \cite{CQS}

\paragraph*{Reduction 2}
We reduce it to another isomorphic topology that looks like a tree, where every process has one incoming edge (except the root) i.e every process can read from one channel but write to multiple channels \cite{CQS}




    

\begin{lemma}\label{testenv-lemma}
Given a directed tree topology with r=0 as the root of the tree
$w \in L_r^e \implies (s_0, s_1, ...,s_n, w \downarrow_{r(0)}, \epsilon, ...,\epsilon) \rightarrow_G^* (f_0, f_1, ..., f_n, \epsilon, \epsilon, ... \epsilon)$
\end{lemma}
   
   
\begin{proof}
Induction on the no. of nodes in the directed tree topology

Base case: We have only one node r,  $L_r^e = {\epsilon} \implies \epsilon \in L_r \implies s_r = f_r$, clearly since we start in $s_r$ it is reachable

Induction: 
Let r be a non-leaf node and let the children be $k_1, k_2, ..., k_m$,  
$w \in L_r^e \implies w \in L_i \cap shuffle(L_{k_1}^e\!\!\!\downarrow_{r}, L_{k_2}^e\!\!\!\downarrow_{r}, ..., L_{k_m}^e\!\!\!\downarrow_{r}, M_{r(i)}^*)$
$w$ is of the form $shuffle(w_1, w_2, ..., w_m)$ where $w_i \in L_{k_i}^e\!\!\!\downarrow_{r(i)}$

$w_i\downarrow_{r(k_i)}$ = $w_i'\downarrow{r(k_i)}$ where $w_i' \in L_{k_i}^e$

Let $\pi_i$ be the tree that is rooted by $k_i$
By induction hypothesis, since $w_i' \in L_{k_i}^e$ we have run from nodes in $\pi$ are in start state, and reader channel of $k_i$ has $w_i'\downarrow{r(k_i)}$ 
to a final configuration where every node is in the final state and all channels are empty.

Since w is in $L_r^e$ it means it is also in $L_r$ we can take this run and convert to the corresponding run in the configuration graph where only r is moving, 
and this w can generate $w_i'\downarrow{r(k_i)}$ in each $k_i$'s reader channel, so we can start from $(s_0, s_1,...,s_n, \epsilon ...) -> (\text{only r moves and fills up all the channels}) -> (f_0, s_1, ..., s_n,\epsilon, w_i\downarrow_{r(k_i)}, ... w_i\downarrow_{r(k_i)} ) -> stitch the k_i run one after the other$ 

    
   \end{proof}
    
   

   
\begin{lemma}\label{testenv-lemma}
Given a directed tree topology with i=0 as the root of the tree.

$(s_0, s_1, ...,s_n, \alpha, \epsilon, ...,\epsilon) \rightarrow_G^* (f_0, f_1, ..., f_n, \epsilon, \epsilon, ... \epsilon) => \exists w \in L_i^e,   \alpha \downarrow_{r(0)} = w \downarrow_{r(0)}$

   \end{lemma}
   
   
   \begin{proof}
    Base case : There is only one node $\alpha$ has to be epsilon 

    Induction: 
    Let r be a non-leaf node, and $k_1, k_2, ..., k_n$ be the children of the r and let the tree rooted by them be $\pi_1, \pi_2, .., \pi_n$ 
    
    Let r run and fill all the reader channels with $\alpha_i$
    For each $k_i$ we form a run from where only nodes in $\pi_i$ are in start state and $\alpha_i$ is in the reader channel of $k_i$, there and final state is reached. Now we use induction hypothesis to say that there is a word in $w_i \in L_{k_i}^e$ and $\alpha_i \downarrow_{r(0)} = w_i \downarrow_{r(0)}$
    
    So we find a $w_i$ for each $k_i$
    
    so we have $w_i \downarrow_{r(i)} \in L_i^e$ 
    so we have  $\alpha_i \in L_i^e$ 
    
    Consider the word $w \in shuffle(\alpha_1, \alpha_2,...\alpha_n, \alpha)$
    $w also belongs to L_r$
    
    $w \in L_r^e$ and $w \downarrow_{r(r)} = \alpha $ 
    
    
    
    
   \end{proof}
    

   
\begin{theorem}\label{testenv-theorem}
    The Reachability problem is decidable for CFMs with FIFO channels over undirected topology. 
   \end{theorem}

   
\begin{proof}
    We use reductions 1 and 2 to get a tree topology
    
   \end{proof}

\section{Conclusions}

Morbi eros magna, vestibulum non posuere non, porta eu quam. Maecenas vitae orci risus, eget imperdiet mauris. Donec massa mauris, pellentesque vel lobortis eu, molestie ac turpis. Sed condimentum convallis dolor, a dignissim est ultrices eu. Donec consectetur volutpat eros, et ornare dui ultricies id. Vivamus eu augue eget dolor euismod ultrices et sit amet nisi. Vivamus malesuada leo ac leo ullamcorper tempor. Donec justo mi, tempor vitae aliquet non, faucibus eu lacus. Donec dictum gravida neque, non porta turpis imperdiet eget. Curabitur quis euismod ligula. 


\begin{thebibliography}{9}

    \bibitem{CQS}
    La Torre, S., Madhusudan, P., Parlato, G. (2008). Context-Bounded Analysis of Concurrent Queue Systems. In: Ramakrishnan, C.R., Rehof, J. (eds) Tools and Algorithms for the Construction and Analysis of Systems. TACAS 2008. Lecture Notes in Computer Science, vol 4963. Springer, Berlin, Heidelberg. \href{https://doi.org/10.1007/978-3-540-78800-3_21}{\texttt{https://doi.org/10.1007/978-3-540-78800-3\_21}}


    \end{thebibliography}

\end{document}
