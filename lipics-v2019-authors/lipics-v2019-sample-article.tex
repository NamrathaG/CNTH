\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2019}

%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
\usepackage{tabto}
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Decidability results of Communicating Finite
State Machines over acyclic topology } %TODO Please add

\titlerunning{} %TODO optional, please use if title is longer than one line

\author{G. Namratha Reddy}{Chennai Mathematical Institute, India \and  \url{http://www.cmi.ac.in/~namratha} }{}{}{}

\authorrunning{G. Namratha Reddy} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

% \Copyright{John Q. Public and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

% \ccsdesc[100]{\textcolor{red}{}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\ccsdesc[500]{Theory of computation~Distributed computing models}


\keywords{Distributed Systems, Reachability, Finite state machines with FIFO queues, Network of concurrent processes} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional nam-maybe-later

%\nolinenumbers %uncomment to disable line numbering

\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \EventEditors{John Q. Open and Joan R. Access}
% \EventNoEds{2}
% \EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
% \EventShortTitle{CVIT 2016}
% \EventAcronym{CVIT}
% \EventYear{2016}
% \EventDate{December 24--27, 2016}
% \EventLocation{Little Whinging, United Kingdom}
% \EventLogo{}
% \SeriesVolume{42}
% \ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
    Models of concurrent finite state processes that communicate over queues allow different reachability results based on the underlying topology. The reachability is known to be undecidable for a general topology, but when we restrict to acyclic topologies it becomes decidable. The paper provides a proof of how it can be decided by reducing the problem to checking emptiness of a certain regular language. 
\end{abstract}

\section{Introduction}
\label{sec:typesetting-summary}

Distributed systems are becoming more and more popular. The ability to achieve with multiple cores/ computers for efficiency, reliability is highly enticing. Applications like block chain, database replication, ... 

These concurrent nature of these applications/programs makes their verification challenging. Techniques to solve this problem are in high demand. 

Formal methods uses mathematical formalism makes it easier to show that certain algorithms are not possible, maybe by showing that they are undecidable/decidable (atleast theoretically) which provides a motivation to develop efficient algorithms that can be used for practical purposes. 

Communicating finite state processes (cite paper) over queues has been a standard model for modelling concurrent non-recursive programs. 

One correctness idea for a concurrent program is to define via a safety property. Which states that a bad state should never be reached in my program. Which translates to asking in the model when we start with the initial configuration is it possible to reach this bad state. 
The answer to this question depends on the model we have considered. 
It turns out that for the communication finite state processes with queues it is undecidable to know if a state is reachable and this is shown because it is turing powerful (cite paper). But when restricted to certain class of topologies it allows for decidablity.


%Explain what exactly do these models model in the real world

%Why is this model helpful?

%Why is reachability important? 




\section{System topology}

\subsection{Model}


\paragraph*{Topology}
We work with a topology which we describe using the tuple 
\begin{center}
$\mathcal{T}= (\mathcal{P}, \mathcal{C}, r, w)$,
\end{center}
where \\
\hspace*{1cm} $\mathcal{P}$ is the set of processes; \\
\hspace*{1cm} $\mathcal{C}$ is the set of channels; \\
\hspace*{1cm} $r:\mathcal{C}  \rightarrow \mathcal{P}$ is the reader function that assigns to each channel a process that can read from it;\\
\hspace*{1cm} $w:\mathcal{C} \rightarrow \mathcal{P}$ is the writer function that assigns to each channel a process that can write to it.


\paragraph*{Channel}

Each channel $c \in \mathcal{C}$ has a message alphabet $\Gamma_c$. We assume channel alphabets are disjoint.\\
Operations on the channel: 
\begin{itemize}
\item $c!m$ is a send operation. It appends the message $m$ to the end of channel $c$
\item $c?m$ is a read operation. It receives the message $m$ from the head of channel $c$ (enabled only if $m$ is at the head of channel $c$)

\end{itemize}


\paragraph*{Process}

Each process $p\in \mathcal{P}$ is modelled as a finite state transtion system 
\begin{center}
   $TS_p = (Q_p, \Delta_p, s_p)$,
\end{center}
where \\
\hspace*{1cm} $Q_p$ is a finite set of states;\\
\hspace*{1cm} $\Delta_p \subseteq Q_p \times O_p \times Q_p$ is a finite set of transitions, where, \\
\hspace*{2cm} $O_p = \{ c?m \hspace{1mm}| \hspace{1mm} r(c) = p,  m \in \Gamma_c\} \cup \{ c!m \hspace{1mm}| \hspace{1mm} w(c) = p, m \in \Gamma_c\}$; \\
\hspace*{1cm} $s_p$ is the initial state.



\subsection{Configuration Graph}


\hspace*{1cm}A configuration $(\alpha, \beta)$ of the system is a pair describing the states of all processes (control state) and the contents of all channels(channel state). \\
\hspace*{5cm} ${\displaystyle \alpha \in \prod_{i \in \mathcal{P}} Q_i}$, ${\displaystyle \beta \in \prod_{c \in \mathcal{C}} \Gamma_c^*}$\\
\hspace*{1cm}For any $p \in \mathcal{P}$, We write $\alpha(p)$ gives the state of process $p$, and for any $c \in \mathcal{C}$, $\beta(c)$ gives the content of channel $c$. $\alpha[p \leftarrow q]$ to be the control state  $\alpha'$ such that $\alpha'(p) = q$, and $\alpha'(p') = \alpha(p')$ if $p' \neq p$. Similarly, we define $\beta[c \leftarrow w]= \beta'$ such that $\beta'(c) = w$, and $\beta'(c') = \beta(c')$ if $c' \neq c$\\
\hspace*{1cm}Vertices in the configuration graph ($G = (V, E)$) are configurations, and the edges are labelled with channel operations. The edges need to satisfy the following conditions. \\
Let $(\alpha, \beta), (\alpha', \beta') \in V, c \in \mathcal{C}$, then 
\begin{itemize}
\item $(\alpha, \beta) \xrightarrow{c!m} (\alpha', \beta')$ if
\begin{itemize}
    \item $\alpha' = \alpha[w(c) \leftarrow \alpha'(w(c))]$
    \item $(\alpha(w(c)), c!m, \alpha'(w(c))) \in \delta_{w(c)}$
    \item $\beta' = \beta[c \leftarrow \beta(c).m]$

\end{itemize}


\item $(\alpha, \beta) \xrightarrow{c?m} (\alpha', \beta')$ if
\begin{itemize}
    \item $\alpha' = \alpha[r(c) \leftarrow \alpha'(r(c))]$
    \item $(\alpha(r(c)), c?m, \alpha'(r(c))) \in \delta_{r(c)}$
    \item $\beta = \beta'[c \leftarrow m.\beta'(c)]$

\end{itemize}
\end{itemize}
\hspace*{1cm}A run is a path in this graph. $c_1 \xrightarrow[G]{*} c_2 $ represents a run starting in $c_1$ and ending in $c_2$.


\section{The Reachability Problem}
\hspace*{1cm} A target control state $\alpha_t$ is said to be reachable if there is a run $c_0 \xrightarrow{*} c_t$, where, $c_0 = (\alpha_0, \beta_0),$  $\alpha_0(p)= s_p \hspace{1mm}\forall p \in \mathcal{P}$, and $\beta_0(c) = \epsilon \hspace{1mm} \forall c \in \mathcal{C}$; $c_t = (\alpha_t, \beta)$ for some $\beta$ \\
\hspace*{1cm}The reachability problem asks whether a given target control state is reachable. We know that the problem is undecidable in general (cite), because if there is a loop in the topology then we can simulate a queue machine and state reachability is undecidable for queue machines. \\
\hspace*{1cm}So we ask the question of whether it is decidable for acyclic topologies.
What we mean by acyclic topologies is consider the network topology and ignore the direction of the edges, so we get an undirected graph and this graph should have no cycles.We solve this with the help of two reductions

\paragraph*{Reductions}

\hspace*{1cm}given such an acyclic topology the reachability problem can be reduced to one in which the target state is reached only if the queue is empty.
We reduce it to another isomorphic topology that looks like a tree, where every process has one incoming edge (except the root) i.e every process can read from one channel but write to multiple channels \cite{CQS}



\paragraph*{Languages}

\hspace*{1cm}Given the target control state $\alpha_t$  to be reached, we define for all $p \in \mathcal{P}$ the language $L_p = L(A_p)$. We get the finite automation $A_p$ by taking the transition system $TS_p$ and replacing the opertion in the transition with just the message and having final state as $\alpha_t(p)$. \\
\hspace{5cm} $A_p= (Q_p, \Sigma_p, \delta_p, s_p, \alpha_t(p))$, 
where, $\Sigma_p = \bigcup\limits_{c \in \mathcal{C}} \{ \Gamma_c : r(c) = p \text{ or } w(c) = p\}$ , $\delta_p = \{(q, m, q') : (q, c?m, q') \in \Delta_p \text{ or } (q, c!m, q') \in \Delta_p\}$

\hspace*{1cm}$\pi_c(w)$ is the word we get by deleting all letter not in $\Gamma_c$. This can be extended to languages as well i.e. $\pi_c(L) = \{ \pi_c(w) : w \in L\}$.

\textbf{TODO later: write a note and motivation }Notice that for $A_p$ to accept a word $w$ which has letters from $r(p)$, the word $\pi_{r(c)}(w)$ needs to be available in the $r(c)$ channel.

We define for all $p \in \mathcal{P}$, $L_P^e$ as follows : 
\begin{itemize}
    \item if $p$ is a leaf node, $L_p^e = L_p \cap \Gamma_{\iota(p)}^*$, where $\iota(p)$ gives the channel that $p$ reads from.
    \item if $p$ is a non-leaf node, and children of $p$ is given by the set $k(p) = \{k_1, k_2, .., k_l\}$, $L_p^e = L_p \cap \text{shuffle}(\{ \pi_{\iota(i)}(L_i^e)  : i \in k(p)\} \cup \{\Gamma_{\iota(p)}^*\})$
\end{itemize}
    
\textbf{TODO Describe what Gp is, describe we want to reach alphat and betat where betat is epsilon, write somewhere that we think root has this dummy reading channel, define shuffle of sets and shuffle of words}


\begin{lemma}\label{testenv-lemma}

Let $p$ be the root of the tree, then \\
\hspace*{2cm}$w \in L_p^e \implies (\alpha_0, \beta_0[\iota(p) \leftarrow \pi_{\iota(p)}(w) ]) \xrightarrow[G_p]{*} (\alpha_t', \beta_t)$, \\
where $\alpha_t'(p) = \alpha_t(p) \text{ for } p \in V_p  \text{ and } \alpha_t'(p) = \alpha_0(p) \text{ for } p \notin V_p$
\end{lemma}
   
\begin{proof} By induction on the no. of nodes in the tree graph $G_p$.

Base case: No. of nodes is 1. Let this node be p. $L_p^e = L_p \cap \Gamma_{\iota(p)}^*$. $w \in L_p^e \implies w \in L_p$, so there is a run  $s_p \xrightarrow[A_p]{w} \alpha_t(p)$. Since p is a leaf node we have $\pi_{\iota(p)}(w) = w$. Therefore, in $G_p$ we get the run $(\langle s_p \rangle , \langle \pi_{\iota(p)}(w) \rangle ) \xrightarrow[G_p]{*} (\langle \alpha_t(p) \rangle , \langle \epsilon \rangle )$

Induction: Let $p$ be a non-leaf node and children of $p$ is given by the set $k(p) = \{k_1, k_2, .., k_l\}$  We have $w \in  L_p \cap \text{shuffle}(\{ \pi_{\iota(i)}(L_i^e)  : i \in k(p)\} \cup \{\Gamma_{\iota(p)}^*\})$
$\implies w \in shuffle(w_1,.., w_l,\pi_{\iota(p)}(w) )$ where $w_i \in \pi_{\iota(i)}(L_i^e)$. 
By induction hypothesis we have run $\rho_i$ : $(\alpha_0, \beta_0[\iota(i) \leftarrow w_i]) \xrightarrow[G_i]{*} (\alpha_t', \beta_t)$ for each $i \in k(p)$. 
Since $w \in L_p$ we have the run $\rho$:  $s_p \xrightarrow[A_p]{*} \alpha_t(p)$. 
Using $\rho$ and the runs for each i, $\rho_i$, we can construct a run in $G_p$ as follows: 
$(\alpha_0, \beta_0[p \leftarrow \pi_{\iota(p)}(w)]) \xrightarrow[\text{p moves}]{*} (\alpha_0[p \leftarrow \alpha_t(p)], \beta_0[\{i \leftarrow w_i : i \in k(p)\}]) \xrightarrow[\text{$k_1$ moves}]{*} \cdots \xrightarrow[\text{$k_l$ moves}]{*} (\alpha_t', \beta_t) $
\end{proof}
    


   
\begin{lemma}\label{testenv-lemma}

Let $p$ be the root of the tree, then \\
\hspace*{2cm}$(\alpha_0, \beta_0[\iota(p) \leftarrow \omega]) \xrightarrow[G_p]{*} (\alpha_t', \beta_t) \implies \exists w \in L_p^e $ such that $\pi_{\iota(p)}(w) = \omega$, \\
where $\alpha_t'(p) = \alpha_t(p) \text{ for } p \in V_p  \text{ and } \alpha_t'(p) = \alpha_0(p) \text{ for } p \notin V_p$


\end{lemma}
   

\begin{proof}
Induction on the no. of nodes in the tree. \\
Base case: No. of nodes is 1. Let this node be p. We have $(\langle s_p \rangle, \langle \omega \rangle ) \xrightarrow[G_p]{*} (\langle \alpha_t(p) \rangle, \langle \epsilon \rangle)$ implies we have the run $s_p \xrightarrow[A_p]{\omega } \alpha_t(p)$ implies $\omega \in L_p^e$ and we can take $w$ as $\omega$ itself since $\pi_{\iota(p)}(\omega) = \omega$. 

Induction: Let $p$ be a non-leaf node and children of $p$ is given by the set $k(p) = \{k_1, k_2, .., k_l\}$. We have the run $\rho: (\alpha_0, \beta_0[\iota(p) \leftarrow \omega]) \xrightarrow[G_p]{*} (\alpha_t', \beta_t)$. 
We can construct another run $\rho'$ in which all the p transitions are taken first and no other process moves until p finishes. Once p finishes let channel state be $\beta'$ 
where $\beta'(\iota(k_i)) = \omega_i$ and the rest of the channels have $\epsilon$. 

Take the corresponding run in $A_p$ and let that be $s_p \xrightarrow[A_p]{w'} \alpha_t(p)$

We can extract the following run from $\rho'$ by taking only transitions of $V_{k_i}$ 

$(\alpha, \beta_0[\iota(k_i) \leftarrow \omega_i]) \xrightarrow[\text{only nodes in $V_{k_i}$ move}]{G_{k_i}} (\alpha_t', \beta_t)$. By induction hypothesis we have some word $w_i \in L_{k_i}^e$ and $\omega_i = \pi_{\iota(k_i)}(w_i) \implies \omega_i \in \pi_{\iota(k_i)}L_{\iota(k_i)}^e$

We have $w' \in shuffle(\omega_1, ..., \omega_l, \omega)$ 
$\implies$ $w' \in L_p^e$ and $\pi_{\iota(p)}(w') = \omega$


\end{proof}
    

   
\begin{theorem}\label{testenv-theorem}
    The Reachability problem is decidable for CFMs with FIFO channels over undirected topology. 
   \end{theorem}

   
\begin{proof}
    We use reductions 1 and 2 to get a tree topology
    
   \end{proof}

\section{Conclusions}

Morbi eros magna, vestibulum non posuere non, porta eu quam. Maecenas vitae orci risus, eget imperdiet mauris. Donec massa mauris, pellentesque vel lobortis eu, molestie ac turpis. Sed condimentum convallis dolor, a dignissim est ultrices eu. Donec consectetur volutpat eros, et ornare dui ultricies id. Vivamus eu augue eget dolor euismod ultrices et sit amet nisi. Vivamus malesuada leo ac leo ullamcorper tempor. Donec justo mi, tempor vitae aliquet non, faucibus eu lacus. Donec dictum gravida neque, non porta turpis imperdiet eget. Curabitur quis euismod ligula. 


\begin{thebibliography}{9}

    \bibitem{CQS}
    La Torre, S., Madhusudan, P., Parlato, G. (2008). Context-Bounded Analysis of Concurrent Queue Systems. In: Ramakrishnan, C.R., Rehof, J. (eds) Tools and Algorithms for the Construction and Analysis of Systems. TACAS 2008. Lecture Notes in Computer Science, vol 4963. Springer, Berlin, Heidelberg. \href{https://doi.org/10.1007/978-3-540-78800-3_21}{\texttt{https://doi.org/10.1007/978-3-540-78800-3\_21}}


    \end{thebibliography}

\end{document}
